"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const AccountId_1 = require("./account/AccountId");
const BasicTypes_pb_1 = require("./generated/BasicTypes_pb");
const util_1 = require("./util");
const Timestamp_pb_1 = require("./generated/Timestamp_pb");
const Timestamp_1 = require("./Timestamp");
const TransactionReceiptQuery_1 = require("./TransactionReceiptQuery");
const TransactionRecordQuery_1 = require("./TransactionRecordQuery");
const Time_1 = require("./Time");
const HederaReceiptStatusError_1 = require("./errors/HederaReceiptStatusError");
const HederaRecordStatusError_1 = require("./errors/HederaRecordStatusError");
/**
 * Normalized transaction ID returned by various methods in the SDK.
 *
 * The ID for a transaction. This is used for retrieving receipts and records for a transaction,
 * for appending to a file right after creating it, for instantiating a smart contract with
 * bytecode in a file just created, and internally by the network for detecting when duplicate
 * transactions are submitted. A user might get a transaction processed faster by submitting it
 * to N nodes, each with a different node account, but all with the same TransactionID. Then,
 * the transaction will take effect when the first of all those nodes submits the transaction
 * and it reaches consensus. The other transactions will not take effect. So this could make the
 * transaction take effect faster, if any given node might be slow. However, the full transaction
 * fee is charged for each transaction, so the total fee is N times as much if the transaction
 * is sent to N nodes.
 */
class TransactionId {
    constructor(id) {
        // Cannot use try/catch here because test die horribly
        // eslint-disable-next-line @typescript-eslint/ban-ts-ignore
        // @ts-ignore
        // eslint-disable-next-line dot-notation
        if (!id["validStart"] && !id["validStartSeconds"]) {
            this.accountId = new AccountId_1.AccountId(id);
            // allows the transaction to be accepted as long as the node isn't 10 seconds behind us
            const { seconds, nanos } = Timestamp_1.dateToTimestamp(Date.now() - 10000);
            this.validStart = new Time_1.Time(seconds, nanos);
        }
        else {
            const transactionId = id;
            if (transactionId instanceof TransactionId) {
                this.accountId = transactionId.accountId;
                this.validStart = new Time_1.Time(transactionId.validStart.seconds, transactionId.validStart.nanos);
            }
            else {
                this.accountId = new AccountId_1.AccountId(transactionId.account);
                if ("validStart" in transactionId) {
                    const { seconds, nanos } = Timestamp_1.dateToTimestamp(transactionId.validStart);
                    this.validStart = new Time_1.Time(seconds, nanos);
                }
                else {
                    this.validStart = new Time_1.Time(transactionId.validStartSeconds, transactionId.validStartNanos);
                }
            }
        }
    }
    static withValidStart(id, validStart) {
        return new TransactionId({
            account: id,
            validStartSeconds: validStart.seconds,
            validStartNanos: validStart.nanos
        });
    }
    static fromString(id) {
        const [account, time] = id.split("@");
        const [seconds, nanos] = time.split(".");
        return new TransactionId({
            account: new AccountId_1.AccountId(account),
            validStartSeconds: Number(seconds),
            validStartNanos: Number(nanos)
        });
    }
    toString() {
        return `${this.accountId.toString()}@${this.validStart.seconds}.${this.validStart.nanos}`;
    }
    getReceipt(client) {
        return __awaiter(this, void 0, void 0, function* () {
            const receipt = yield new TransactionReceiptQuery_1.TransactionReceiptQuery()
                .setTransactionId(this)
                .execute(client);
            // Throw an exception on an invalid receipt status
            HederaReceiptStatusError_1.HederaReceiptStatusError._throwIfError(receipt.status.code, receipt, this);
            return receipt;
        });
    }
    getRecord(client) {
        return __awaiter(this, void 0, void 0, function* () {
            // Wait for consensus using a free query first
            try {
                yield this.getReceipt(client);
            }
            catch (error) {
                if (!(error instanceof HederaReceiptStatusError_1.HederaReceiptStatusError)) {
                    throw error;
                }
            }
            const record = yield new TransactionRecordQuery_1.TransactionRecordQuery()
                .setTransactionId(this)
                .execute(client);
            HederaRecordStatusError_1.HederaRecordStatusError._throwIfError(record.receipt.status.code, record, this);
            return record;
        });
    }
    // NOT A STABLE API
    static _fromProto(id) {
        const seconds = util_1.orThrow(id.getTransactionvalidstart()).getSeconds();
        const nanos = util_1.orThrow(id.getTransactionvalidstart()).getNanos();
        return new TransactionId({
            account: AccountId_1.AccountId._fromProto(util_1.orThrow(id.getAccountid())),
            validStartSeconds: seconds,
            validStartNanos: nanos
        });
    }
    // NOT A STABLE API
    _toProto() {
        const txnId = new BasicTypes_pb_1.TransactionID();
        txnId.setAccountid(this.accountId._toProto());
        const ts = new Timestamp_pb_1.Timestamp();
        ts.setSeconds(this.validStart.seconds);
        ts.setNanos(this.validStart.nanos);
        txnId.setTransactionvalidstart(ts);
        return txnId;
    }
}
exports.TransactionId = TransactionId;
